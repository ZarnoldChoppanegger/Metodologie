## Container(s) ##
**Contenitori sequenziali:** gli elementi al loro interno sono definiti in un ordinamento e si trovano sempre nella stessa posizione.
**Contenitori associativi:** gli elementi al loro interno sono associati ad una chiave e la loro ricerca avviente per mezzo di questa.

Lo standard non definisce quale deve essere la struttura interna di un contenitore. Ne definisce però l'interfaccia e complessità. L'implementazione del contenitore è a carico dell'implementatore che deciderà di fare le cose più appropriate per ottimizzare.

### Vector ###
``` c++
template<typename T, 
                  typename Allocator = std::allocator<T>>
class Vector;
```
* Struttura dati sequenziale, simile a un array. Gli elementi sono adiacenti l'uno all'altro, quindi è possibile accederci non solo mediante iteratori ma anche mediante offset su regolari puntatori agli elementi del vector. 
* Il vector occupa più memoria di un normale vettore statico, questo perchè viene allocato più spazio per futuri inserimenti e quindi evitare riallocazioni frequenti, ma solo quando necessario. È possibile vedere lo spazio allocato mediante la funzione membro `capacity()` e ritornare al sistema la memoria non utilizzata mediante la funzione `shrink_to_fit()`, implementata con `copy & swap`.
* Allocazione di memoria è in generale un'operazione costosa, quindi è possibile allocare una quantità di memoria predefinita mediante la funzione membro `reserve()`, eliminando quindi riallocazione.
* [insert()!](http://en.cppreference.com/w/cpp/container/vector/insert) ha diverse interfacce, lo scopo principale è inserire uno o n elementi prima di una data posizione. Durante gli inseriementi gli iteratori possono invalidarsi, quindi bisogna stare attenti. L'**inserimento di un solo elemento** è implementato con **exception safe forte**, quello di più elementi no, quindi dopo tanti inseriemnti, se questi non vanno a buon fine, non conosciamo nulla della struttura del vector.

``` c++
iterator insert( iterator pos, const T& value );
iterator insert( const_iterator pos, size_type count, const T& value );
```
* [remove()!](http://en.cppreference.com/w/cpp/container/vector/erase) rimuove gli elementi in una data posizione o in un range. 

### Map ###
La map è un container associativo ordinato, che contiene coppie di chiavi-valori con chiavi uniche.
Le chiavi vengono ordinate usando la funzione `Compare`, la quale determina che due chiavi sono equivalenti (non uniche) se nessuno dei due risulta essere minore dell'altro. Ovvero il criterio di ordinameto è [Strickt Weak Ordering!](https://en.wikipedia.org/wiki/Weak_ordering).

## Algoritmi ##

* Gli algoritmi della STL sono scritti in modo da poter essere utilizzati su tutti i contenitori della STL. Questo è possibile poichè gli algoritmi non lavorano sui contenitori ma con gli iteratori dei contenitori. Cioè lavorano su **sequenze** definite da coppie di iteratori (per input) o singoli iteratori (per output).
* Quando si lavora su due sequenze gli algoritmi prendono come parametri la coppia di iteratori identificanti la prima sequenza (inizio e fine), e un iteratore identificante la seconda sequenza (inizio). Non è richiesta anche la fine per la seconda sequenza poichè si ha la precondizione che la seconda sequenza sia almeno lunga quanto la prima.
* Questo può portare l'utente a fare errori, come scrivere su locazioni di memoria non valide, poichè ha sbagliato a passare gli iteratori o perchè questi sono stati invalidati. Sarebbe più semplice per l'utente che gli algoritmi lavorassero sui contenitori direttamente, in questo modo si eviterebbero tutti i possibili errori, ma ciò renderebbe gli algoritmi poco generici, questi infatti lavorerebbero solo su specifici contenitori e richiederebbero specifiche implementazioni. Essendo i contenitori N e gli algoritmi M, il numero di algoritmi da implementare sarebbe N * M. Oltretutto  non è possibile lavorare su sottosequenze dei contenitori se non mediante gli iteratori.
* La maggiorparte degli algoritmi al termine dell'esecuzione ritornano un iteratore, tranne in rare eccezioni quando bisogna ritornare un oggetto di tipo `pair`, costituito da una coppia di iteratori. Il motivo fondamentale sta nel fatto che quando la STL è stata creata non c'era ancora la semantica di spostamento, quindi l'unico modo efficiente per ottenere informazioni dagli algoritmi era mediante gli iteratori. 
* Ci sono algoritmi con predicati e algortimi senza predicati. Questo incrementa la flessibilità della STL e i suoi usi. Le funzioni che prendono come parametro anche un predicato hanno come suffisso `_if`; questa distinzione viene fatta per disambiguare, un predicato infatti a volte può essere interpretato come un elemento da confrontare con gli elementi della sequenza. 
* È bene che i predicati non modifichino mai gli elementi su cui vengono applicati nell'algoritmo, questo perchè rende oscure le operazioni fatte sull'oggetto. Per evitare incidenti, passare oggetti ai predicati per `const reference`.
* Allo stesso modo i predicati non dovrebbero avere uno stato che cambia, alterando il significato dell'operazione. Gli algoritmi copiano un predicato e quindi il cambiamento di stato può portare a comportamenti indefiniti. 
* La complessità degli algoritmi è specificata dallo standard

**Scrivere alcuni algoritmi fatti a lezione**
* **search()** algoritmo che permette di ricercare una sequenza come sottosequenza di un'altra. Utile per le stringe. Per trovare un solo elemento usare `binary_search()` oppure `find()`.
* **copy(b, e, out)** copia gli elementi del range `[b, e)` nella sequenza descritta da `out`, il quale è un iteratore di output. Quindi questo significa che si possono scrivere elementi su qualsiasi contenitore basta che questo possa essere descritto con un output iterator.

``` c++

```

## Iteratori ##

> Gli iteratori esistono principalmente per isolare gli algoritmi dalle strutture dati (contenitori) su cui operano e vice versa




